{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Warning This documentation is actively being built and reach its final form in the coming weeks. Welcome to the ~ Melodoc ~. Melody is an internet sensor built for threat intelligence. This tool have multiple use cases : Build historic data to extract trends and patterns Keep an eye on specific threats Monitor emerging threats exploitation Index malicious activity by detecting exploitation attempts and targeted scanners Log every contact your application receives from the internet to find potentially malicious activity Deploying it can be as easy as pulling the latest compiled binary or the official Docker image. Add your favorite rules, some configuration tweaks, a BPF to clean the noise a bit and then forget it 1 and let the internet symphony flow to you. You can tweak the options either with a file or directly by passing options trough the CLI, allowing Melody to act as a standalone application. Melody will also handle log rotation for you. It has been designed to be able to run forever on the smallest VPS while handling millions of packets a day. You should either setup an automated patching process or come back often to apply security patches on the host though \u21a9","title":"Home"},{"location":"features/","text":"Here are some key features of Melody : Transparent capture Write detection rules and tag specific packets to analyze them at scale Mock vulnerable websites using the builtin HTTP/S server Supports the main internet protocols over IPv4 and IPv6 Handles log rotation for you : Melody is designed to run forever on the smallest VPS Minimal configuration required Standalone mode : configure Melody using only the CLI Easily scalable : Statically compiled binary Up-to-date Docker image Additional features on the roadmap include : Dedicated helper program to create, test and manage rules Centralized rules management","title":"Features"},{"location":"installation/","text":"To install Melody, use make install or enter the following commands : go build -ldflags = \"-s -w -extldflags=-static\" -o melody sudo setcap cap_net_raw,cap_setpcap = ep ./melody mkdir /opt/melody ln -s \" $( pwd ) /melody\" /opt/melody/ ln -s \" $( pwd ) /config.yml\" /opt/melody/config.yml ln -s \" $( pwd ) /filter.bpf\" /opt/melody/filter.bpf ln -s \" $( pwd ) /rules\" /opt/melody/rules echo \"> Setting listening interface to \\\" $( route | grep '^default' | grep -o '[^ ]*$' ) \\\"\" sed -i \"s/# listen.interface: \\\"lo\\\"/listen.interface: \\\" $( route | grep '^default' | grep -o '[^ ]*$' ) \\\"/g\" /opt/melody/config.yml echo echo -n \"Current listening interface :\\n\\t\" grep listen.interface /opt/melody/config.yml echo \"Current BPF is ' $( cat /opt/melody/filter.bpf ) '\" # Don't forget to filter the noise by editing filter.bpf Systemd # You can tweak the provided service file to use Melody with systemd . The file can be found in $melody/etc/melody.service . Example [Unit] Description=Melody sensor After=network-online.target [Service] Type=simple WorkingDirectory=/opt/melody ExecStart=/opt/melody/melody Restart=on-failure # User=melody # Group=melody [Install] WantedBy=multi-user.target Install it with : make service or sudo ln -s \" $( pwd ) /etc/melody.service\" /etc/systemd/system/melody.service sudo systemctl daemon-reload sudo systemctl enable melody sudo systemctl status melody Supervisord # You can also tweak the provided configuration file to use Melody with supervisord . The file can be found in $melody/etc/melody.conf . Example [program:melody] command=/opt/melody/melody directory=/opt/melody stdout_logfile=/opt/melody/melody.out stderr_logfile=/opt/melody/melody.err autostart=true autorestart=true stopasgroup=true killasgroup=true Install it with : make supervisor or sudo ln -s $( pwd ) /etc/melody.conf /etc/supervisor/conf.d/melody.conf sudo supervisorctl reload sudo supervisorctl status all Uninstall # Uninstall by removing log directories (default $melody/logs ), service files ( /etc/systemd/system/melody.service and /etc/supervisor/conf.d/melody.conf ) and Melody home directory (default /opt/melody ). Example Uncomment and use these command carefully. # sudo systemctl stop melody && rm /etc/systemd/system/melody.service # sudo supervisorctl stop melody && rm /etc/supervisor/conf.d/melody.conf # rm -rf /opt/melody Danger Keep in mind that removing Melody's home directory will most likely remove its logs directory as well. All log data might be lost.","title":"Installation"},{"location":"installation/#systemd","text":"You can tweak the provided service file to use Melody with systemd . The file can be found in $melody/etc/melody.service . Example [Unit] Description=Melody sensor After=network-online.target [Service] Type=simple WorkingDirectory=/opt/melody ExecStart=/opt/melody/melody Restart=on-failure # User=melody # Group=melody [Install] WantedBy=multi-user.target Install it with : make service or sudo ln -s \" $( pwd ) /etc/melody.service\" /etc/systemd/system/melody.service sudo systemctl daemon-reload sudo systemctl enable melody sudo systemctl status melody","title":"Systemd"},{"location":"installation/#supervisord","text":"You can also tweak the provided configuration file to use Melody with supervisord . The file can be found in $melody/etc/melody.conf . Example [program:melody] command=/opt/melody/melody directory=/opt/melody stdout_logfile=/opt/melody/melody.out stderr_logfile=/opt/melody/melody.err autostart=true autorestart=true stopasgroup=true killasgroup=true Install it with : make supervisor or sudo ln -s $( pwd ) /etc/melody.conf /etc/supervisor/conf.d/melody.conf sudo supervisorctl reload sudo supervisorctl status all","title":"Supervisord"},{"location":"installation/#uninstall","text":"Uninstall by removing log directories (default $melody/logs ), service files ( /etc/systemd/system/melody.service and /etc/supervisor/conf.d/melody.conf ) and Melody home directory (default /opt/melody ). Example Uncomment and use these command carefully. # sudo systemctl stop melody && rm /etc/systemd/system/melody.service # sudo supervisorctl stop melody && rm /etc/supervisor/conf.d/melody.conf # rm -rf /opt/melody Danger Keep in mind that removing Melody's home directory will most likely remove its logs directory as well. All log data might be lost.","title":"Uninstall"},{"location":"layers/","text":"HTTP # Rules # Key Type Example http.uri complex http.uri: contains: - \"/console/css/%2e\" http.body complex http.body: contains: - \"I made a discovery today.\" http.headers complex http.headers: is: - \"User-agent: Mozilla/5.0 zgrab/0.x\" http.method complex http.method: is: - \"POST\" http.proto complex http.proto: is: - \"HTTP/1.1\" http.tls bool false Note HTTP rules applies to HTTPS packets as well. Important HTTP being an application protocol, the full packet is assembled from multiple frames and thus does not have its transport information embedded. However, the reassembled packet data share its session with the TCP frames it comes from. You can link them together by looking up the session. Note Since HTTPS packets are captured by the webserver and not reassembled, they have their own session and are not linked with the assembled frames. Log data # Example { \"http\" : { \"verb\" : \"POST\" , \"proto\" : \"HTTP/1.1\" , \"uri\" : \"/\" , \"src_port\" : 51746 , \"dst_host\" : \"127.0.0.1\" , \"user_agent\" : \"curl/7.58.0\" , \"headers\" : { \"Accept\" : \"*/*\" , \"Content-Length\" : \"14\" , \"Content-Type\" : \"application/x-www-form-urlencoded\" , \"User-Agent\" : \"curl/7.58.0\" }, \"headers_keys\" : [ \"User-Agent\" , \"Accept\" , \"Content-Length\" , \"Content-Type\" ], \"headers_values\" : [ \"curl/7.58.0\" , \"*/*\" , \"14\" , \"application/x-www-form-urlencoded\" ], \"errors\" : null , \"body\" : { \"content\" : \"Enter my world\" , \"base64\" : \"RW50ZXIgbXkgd29ybGQ=\" , \"truncated\" : false }, \"is_tls\" : false }, \"ip\" : null , \"timestamp\" : \"2020-11-17T21:16:23.847161686+01:00\" , \"session\" : \"buq2v5oo4skos28gfp20\" , \"type\" : \"http\" , \"src_ip\" : \"127.0.0.1\" , \"dst_port\" : 10080 , \"matches\" : {}, \"embedded\" : {} } Info The errors field contains the error met while parsing the request body or the Host field. TCP # Rules # Key Type Example tcp.payload complex tcp.payload: contains: - \"/console/css/%2e\" tcp.flags flags tcp.flags: - \"PA\" - \"S\" tcp.fragbits flags tcp.fragbits: - \"M\" tcp.dsize number tcp.dsize: 1234 tcp.seq number tcp.seq: 4321 tcp.ack number tcp.ack: 0 tcp.window number tcp.window: 512 TCP flags values : Keyword Name Value F FIN 0x01 S SYN 0x02 R RST 0x04 P PSH 0x08 A ACK 0x10 U URG 0x20 E ECE 0x40 C CWR 0x80 0 NULL 0x00 TCP fragbits values : Keyword Name Value M More Fragments 0x01 D Don't Fragment 0x02 R Reserved Bit 0x04 Log data # Example { \"tcp\" : { \"window\" : 512 , \"seq\" : 1906765553 , \"ack\" : 2514263732 , \"data_offset\" : 8 , \"flags\" : \"PA\" , \"urgent\" : 0 , \"payload\" : { \"content\" : \"I made a discovery today. I found a computer.\\n\" , \"base64\" : \"SSBtYWRlIGEgZGlzY292ZXJ5IHRvZGF5LiAgSSBmb3VuZCBhIGNvbXB1dGVyLgo=\" , \"truncated\" : false } }, \"ip\" : { \"version\" : 4 , \"ihl\" : 5 , \"tos\" : 0 , \"length\" : 99 , \"id\" : 39114 , \"fragbits\" : \"DF\" , \"frag_offset\" : 0 , \"ttl\" : 64 , \"protocol\" : 6 }, \"timestamp\" : \"2020-11-16T15:50:01.277828+01:00\" , \"session\" : \"bup9368o4skolf20rt8g\" , \"type\" : \"tcp\" , \"src_ip\" : \"127.0.0.1\" , \"dst_port\" : 1234 , \"matches\" : {}, \"embedded\" : {} } UDP # Rules # Key Type Example udp.payload complex udp.payload: contains: - \"/console/css/%2e\" udp.checksum number udp.checksum: 0xfe37 udp.length number udp.length: 36 udp.dsize number udp.dsize: 28 Tip udp.dsize check the payload size, while the udp.length check the UDP packet's length. Log data # Example { \"udp\" : { \"payload\" : { \"content\" : \"I made a discovery today. I found a computer.\\n\" , \"base64\" : \"SSBtYWRlIGEgZGlzY292ZXJ5IHRvZGF5LiBJIGZvdW5kIGEgY29tcHV0ZXIuCg==\" , \"truncated\" : false }, \"length\" : 54 , \"checksum\" : 65097 }, \"ip\" : { \"version\" : 4 , \"ihl\" : 5 , \"tos\" : 0 , \"length\" : 74 , \"id\" : 3230 , \"fragbits\" : \"DF\" , \"frag_offset\" : 0 , \"ttl\" : 64 , \"protocol\" : 17 }, \"timestamp\" : \"2020-11-17T19:02:12.90819+01:00\" , \"session\" : \"buq1090o4sktrqnfoe6g\" , \"type\" : \"udp\" , \"src_ip\" : \"127.0.0.1\" , \"dst_port\" : 1234 , \"matches\" : {}, \"embedded\" : {} } ICMPv4 # Rules # Key Type Example icmpv4.payload complex icmpv4.payload: contains: - \"the world of the electron and the switch\" icmpv4.typecode number icmpv4.typecode: 2048 icmpv4.type number icmpv4.type: 0x8 icmpv4.code number icmpv4.code: 0 icmpv4.seq number icmpv4.seq: 1 icmpv4.checksum number icmpv4.checksum: 0x0416 Log data # Example { \"icmpv4\" : { \"type_code\" : 2048 , \"type\" : 8 , \"code\" : 0 , \"type_code_name\" : \"EchoRequest\" , \"checksum\" : 10240 , \"id\" : 0 , \"seq\" : 0 , \"payload\" : { \"content\" : \"the world of the electron and the switch\" , \"base64\" : \"dGhlIHdvcmxkIG9mIHRoZSBlbGVjdHJvbiBhbmQgdGhlIHN3aXRjaA==\" , \"truncated\" : false } }, \"ip\" : { \"version\" : 4 , \"ihl\" : 5 , \"tos\" : 0 , \"length\" : 68 , \"id\" : 1 , \"fragbits\" : \"\" , \"frag_offset\" : 0 , \"ttl\" : 64 , \"protocol\" : 1 }, \"timestamp\" : \"2020-11-18T12:47:25.101191+01:00\" , \"session\" : \"n/a\" , \"type\" : \"icmpv4\" , \"src_ip\" : \"127.0.0.1\" , \"dst_port\" : 0 , \"matches\" : {}, \"embedded\" : {} } ICMPv6 # Rules # Key Type Example icmpv6.payload complex icmpv6.payload: contains: - \"the world of the electron and the switch\" icmpv6.typecode number icmpv6.typecode: 32768 icmpv6.type number icmpv6.type: 0x80 icmpv6.code number icmpv6.code: 0 icmpv6.checksum number icmpv6.checksum: 0x275b Log data # Example { \"icmpv6\" : { \"type_code\" : 32768 , \"type\" : 128 , \"code\" : 0 , \"type_code_name\" : \"EchoRequest\" , \"checksum\" : 44947 , \"payload\" : { \"content\" : \"\\u0000\\u0000\\u0000\\u0000the world of the electron and the switch\" , \"base64\" : \"AAAAAHRoZSB3b3JsZCBvZiB0aGUgZWxlY3Ryb24gYW5kIHRoZSBzd2l0Y2g=\" , \"truncated\" : false } }, \"ip\" : { \"version\" : 6 , \"length\" : 48 , \"next_header\" : 58 , \"next_header_name\" : \"ICMPv6\" , \"traffic_class\" : 0 , \"flow_label\" : 0 , \"hop_limit\" : 64 }, \"timestamp\" : \"2020-11-18T12:42:47.461931+01:00\" , \"session\" : \"n/a\" , \"type\" : \"icmpv6\" , \"src_ip\" : \"::1\" , \"dst_port\" : 0 , \"matches\" : {}, \"embedded\" : {} }","title":"Layers"},{"location":"layers/#http","text":"","title":"HTTP"},{"location":"layers/#rules","text":"Key Type Example http.uri complex http.uri: contains: - \"/console/css/%2e\" http.body complex http.body: contains: - \"I made a discovery today.\" http.headers complex http.headers: is: - \"User-agent: Mozilla/5.0 zgrab/0.x\" http.method complex http.method: is: - \"POST\" http.proto complex http.proto: is: - \"HTTP/1.1\" http.tls bool false Note HTTP rules applies to HTTPS packets as well. Important HTTP being an application protocol, the full packet is assembled from multiple frames and thus does not have its transport information embedded. However, the reassembled packet data share its session with the TCP frames it comes from. You can link them together by looking up the session. Note Since HTTPS packets are captured by the webserver and not reassembled, they have their own session and are not linked with the assembled frames.","title":"Rules"},{"location":"layers/#log-data","text":"Example { \"http\" : { \"verb\" : \"POST\" , \"proto\" : \"HTTP/1.1\" , \"uri\" : \"/\" , \"src_port\" : 51746 , \"dst_host\" : \"127.0.0.1\" , \"user_agent\" : \"curl/7.58.0\" , \"headers\" : { \"Accept\" : \"*/*\" , \"Content-Length\" : \"14\" , \"Content-Type\" : \"application/x-www-form-urlencoded\" , \"User-Agent\" : \"curl/7.58.0\" }, \"headers_keys\" : [ \"User-Agent\" , \"Accept\" , \"Content-Length\" , \"Content-Type\" ], \"headers_values\" : [ \"curl/7.58.0\" , \"*/*\" , \"14\" , \"application/x-www-form-urlencoded\" ], \"errors\" : null , \"body\" : { \"content\" : \"Enter my world\" , \"base64\" : \"RW50ZXIgbXkgd29ybGQ=\" , \"truncated\" : false }, \"is_tls\" : false }, \"ip\" : null , \"timestamp\" : \"2020-11-17T21:16:23.847161686+01:00\" , \"session\" : \"buq2v5oo4skos28gfp20\" , \"type\" : \"http\" , \"src_ip\" : \"127.0.0.1\" , \"dst_port\" : 10080 , \"matches\" : {}, \"embedded\" : {} } Info The errors field contains the error met while parsing the request body or the Host field.","title":"Log data"},{"location":"layers/#tcp","text":"","title":"TCP"},{"location":"layers/#rules_1","text":"Key Type Example tcp.payload complex tcp.payload: contains: - \"/console/css/%2e\" tcp.flags flags tcp.flags: - \"PA\" - \"S\" tcp.fragbits flags tcp.fragbits: - \"M\" tcp.dsize number tcp.dsize: 1234 tcp.seq number tcp.seq: 4321 tcp.ack number tcp.ack: 0 tcp.window number tcp.window: 512 TCP flags values : Keyword Name Value F FIN 0x01 S SYN 0x02 R RST 0x04 P PSH 0x08 A ACK 0x10 U URG 0x20 E ECE 0x40 C CWR 0x80 0 NULL 0x00 TCP fragbits values : Keyword Name Value M More Fragments 0x01 D Don't Fragment 0x02 R Reserved Bit 0x04","title":"Rules"},{"location":"layers/#log-data_1","text":"Example { \"tcp\" : { \"window\" : 512 , \"seq\" : 1906765553 , \"ack\" : 2514263732 , \"data_offset\" : 8 , \"flags\" : \"PA\" , \"urgent\" : 0 , \"payload\" : { \"content\" : \"I made a discovery today. I found a computer.\\n\" , \"base64\" : \"SSBtYWRlIGEgZGlzY292ZXJ5IHRvZGF5LiAgSSBmb3VuZCBhIGNvbXB1dGVyLgo=\" , \"truncated\" : false } }, \"ip\" : { \"version\" : 4 , \"ihl\" : 5 , \"tos\" : 0 , \"length\" : 99 , \"id\" : 39114 , \"fragbits\" : \"DF\" , \"frag_offset\" : 0 , \"ttl\" : 64 , \"protocol\" : 6 }, \"timestamp\" : \"2020-11-16T15:50:01.277828+01:00\" , \"session\" : \"bup9368o4skolf20rt8g\" , \"type\" : \"tcp\" , \"src_ip\" : \"127.0.0.1\" , \"dst_port\" : 1234 , \"matches\" : {}, \"embedded\" : {} }","title":"Log data"},{"location":"layers/#udp","text":"","title":"UDP"},{"location":"layers/#rules_2","text":"Key Type Example udp.payload complex udp.payload: contains: - \"/console/css/%2e\" udp.checksum number udp.checksum: 0xfe37 udp.length number udp.length: 36 udp.dsize number udp.dsize: 28 Tip udp.dsize check the payload size, while the udp.length check the UDP packet's length.","title":"Rules"},{"location":"layers/#log-data_2","text":"Example { \"udp\" : { \"payload\" : { \"content\" : \"I made a discovery today. I found a computer.\\n\" , \"base64\" : \"SSBtYWRlIGEgZGlzY292ZXJ5IHRvZGF5LiBJIGZvdW5kIGEgY29tcHV0ZXIuCg==\" , \"truncated\" : false }, \"length\" : 54 , \"checksum\" : 65097 }, \"ip\" : { \"version\" : 4 , \"ihl\" : 5 , \"tos\" : 0 , \"length\" : 74 , \"id\" : 3230 , \"fragbits\" : \"DF\" , \"frag_offset\" : 0 , \"ttl\" : 64 , \"protocol\" : 17 }, \"timestamp\" : \"2020-11-17T19:02:12.90819+01:00\" , \"session\" : \"buq1090o4sktrqnfoe6g\" , \"type\" : \"udp\" , \"src_ip\" : \"127.0.0.1\" , \"dst_port\" : 1234 , \"matches\" : {}, \"embedded\" : {} }","title":"Log data"},{"location":"layers/#icmpv4","text":"","title":"ICMPv4"},{"location":"layers/#rules_3","text":"Key Type Example icmpv4.payload complex icmpv4.payload: contains: - \"the world of the electron and the switch\" icmpv4.typecode number icmpv4.typecode: 2048 icmpv4.type number icmpv4.type: 0x8 icmpv4.code number icmpv4.code: 0 icmpv4.seq number icmpv4.seq: 1 icmpv4.checksum number icmpv4.checksum: 0x0416","title":"Rules"},{"location":"layers/#log-data_3","text":"Example { \"icmpv4\" : { \"type_code\" : 2048 , \"type\" : 8 , \"code\" : 0 , \"type_code_name\" : \"EchoRequest\" , \"checksum\" : 10240 , \"id\" : 0 , \"seq\" : 0 , \"payload\" : { \"content\" : \"the world of the electron and the switch\" , \"base64\" : \"dGhlIHdvcmxkIG9mIHRoZSBlbGVjdHJvbiBhbmQgdGhlIHN3aXRjaA==\" , \"truncated\" : false } }, \"ip\" : { \"version\" : 4 , \"ihl\" : 5 , \"tos\" : 0 , \"length\" : 68 , \"id\" : 1 , \"fragbits\" : \"\" , \"frag_offset\" : 0 , \"ttl\" : 64 , \"protocol\" : 1 }, \"timestamp\" : \"2020-11-18T12:47:25.101191+01:00\" , \"session\" : \"n/a\" , \"type\" : \"icmpv4\" , \"src_ip\" : \"127.0.0.1\" , \"dst_port\" : 0 , \"matches\" : {}, \"embedded\" : {} }","title":"Log data"},{"location":"layers/#icmpv6","text":"","title":"ICMPv6"},{"location":"layers/#rules_4","text":"Key Type Example icmpv6.payload complex icmpv6.payload: contains: - \"the world of the electron and the switch\" icmpv6.typecode number icmpv6.typecode: 32768 icmpv6.type number icmpv6.type: 0x80 icmpv6.code number icmpv6.code: 0 icmpv6.checksum number icmpv6.checksum: 0x275b","title":"Rules"},{"location":"layers/#log-data_4","text":"Example { \"icmpv6\" : { \"type_code\" : 32768 , \"type\" : 128 , \"code\" : 0 , \"type_code_name\" : \"EchoRequest\" , \"checksum\" : 44947 , \"payload\" : { \"content\" : \"\\u0000\\u0000\\u0000\\u0000the world of the electron and the switch\" , \"base64\" : \"AAAAAHRoZSB3b3JsZCBvZiB0aGUgZWxlY3Ryb24gYW5kIHRoZSBzd2l0Y2g=\" , \"truncated\" : false } }, \"ip\" : { \"version\" : 6 , \"length\" : 48 , \"next_header\" : 58 , \"next_header_name\" : \"ICMPv6\" , \"traffic_class\" : 0 , \"flow_label\" : 0 , \"hop_limit\" : 64 }, \"timestamp\" : \"2020-11-18T12:42:47.461931+01:00\" , \"session\" : \"n/a\" , \"type\" : \"icmpv6\" , \"src_ip\" : \"::1\" , \"dst_port\" : 0 , \"matches\" : {}, \"embedded\" : {} }","title":"Log data"},{"location":"links/","text":"The project is maintained in the Github repository Follow @bonjourmalware on Twitter for updates","title":"Links"},{"location":"quickstart/","text":"TL;DR # Release # Get the latest release at https://github.com/bonjourmalware/actions-lab/releases . make install # Set default outfacing interface make certs # Make self signed certs for the HTTPS fileserver make default_rules # Enable the default rules make service # Create a systemd service to restart the program automatically and launch it at startup # Note that the script expects that you've installed Melody in /opt/melody sudo systemctl stop melody # Stop the service while we're configuring it Update the filter.bpf file to filter out unwanted packets. sudo systemctl start melody # Start Melody sudo systemctl status melody # Check that Melody is running The logs should start to pile up in /opt/melody/logs/melody.ndjson . tail -f /opt/melody/logs/melody.ndjson # | jq From source # git clone https://github.com/bonjourmalware/melody /opt/melody cd /opt/melody make build Then continue with the steps from the release TL;DR. Docker # mkdir -p /opt/melody/logs cd /opt/melody/ docker pull bonjourmalware/melody:latest MELODY_CLI = \"\" # Put your CLI options here. Example : MELODY_CLI=\"-s -o 'http.server.port: 5555'\" docker run \\ --net = host \\ -e \"MELODY_CLI= $MELODY_CLI \" \\ --mount type = bind,source = \" $( pwd ) \" /filter.bpf,target = /app/filter.bpf,readonly \\ # Remove this line if you're using the default filter --mount type = bind,source = \" $( pwd ) \" /config.yml,target = /app/config.yml,readonly \\ # Remove this line if you're using the default config --mount type = bind,source = \" $( pwd ) \" /logs,target = /app/logs/ \\ # The directory must exists in your current directory before running the container melody The logs should start to pile up in /opt/melody/logs/melody.ndjson . Before we start # Hi ! You'll need the following info : The name of the interface on which you want Melody to listen to wlp3s0, ens3, enp0s25, eth0... All the IP addresses to exclude from monitoring Tip Don't forget to exclude the IP from which you're SSH'ing Clone the repo to get the default rules and configuration files : git clone https://github.com/bonjourmalware/melody Tip You can also write the configuration files later or use CLI options to use it as a standalone binary Firewall # Don't forget to check your firewall to ensure you're not blocking packets from reaching the sensor. Build from source # Warning You need the libpcap headers before building Melody. Install them with : sudo apt update sudo apt install libpcap-dev Build Melody with : make build or go build -ldflags=\"-s -w -extldflags=-static\" -o melody sudo setcap cap_net_raw,cap_setpcap=ep ./melody Grab a release # You can grab the latest release by visiting https://github.com/bonjourmalware/melody/releases/latest . Docker # You can also use Docker and pull the image from Docker Hub : docker pull bonjourmalware/melody:latest Run it with : docker run \\ --net=host \\ --mount type=bind,source=\"$(pwd)\"/filter.bpf,target=/app/filter.bpf,readonly \\ --mount type=bind,source=\"$(pwd)\"/config.yml,target=/app/config.yml,readonly \\ --mount type=bind,source=\"$(pwd)\"/logs,target=/app/logs/ \\ melody Configuration # Melody configuration # All the available configuration options are listed with their default values in the config.yml file. You'll want to look at a few things before getting started : Set the listen.interface to the one on which you want Melody to be listening on Tip On most recent linux distribution, you can run route | grep '^default' | grep -o '[^ ]*$' to find the default WAN card. Tip On Windows, you'll want an interface name like \\Device\\NPF_{4E273621-5161-46C8-895A-48D0E52A0B83} . If you find an interface name with TCP in place of NPF , try swaping both. See Find Windows interfaces for more details. Don't forget to wrap your string with ' to prevent the parsing of the escaping \\ : interface: '\\Device\\NPF_{4E273621-5161-46C8-895A-48D0E52A0B83}' Note Note that Melody listen on lo by default. You can override the listening interface with the -i switch. The dummy HTTP/S servers are enabled by default. Disable it if you're not interested by this data, or you're putting Melody next to a web application Default rules are disabled by default. You can enable them by creating a symlink for each rule to enable in the active rule directory specified in the configuration file ( $melody/rules/rules-enabled by default) Tip To create a symlink, use the following command from the root of the projet : ln -rs ./rules/rules-available/ $rule .yml ./rules/rules-enabled/ Use a wildcard to enable all the rulesets : ln -rs ./rules/rules-available/*.yml ./rules/rules-enabled/ HTTP/S server # In order to capture the full HTTP transactions, the client must have a server to connect to. To ease that process, a dummy HTTP/S server is available. The default configuration is to answer 200 OK on every routes, along with a Server: Apache header. iptables # To capture the HTTP traffic your server receives on every ports, I recommend using iptables to redirect the data from every ports to the one Melody is listening on. Danger Be very careful while applying these modifications. You must at least exclude your remote connection port using the ! --dports switch, or you will be locked out. To achieve this, add a rule to your PREROUTING table : sudo iptables -A PREROUTING -t nat -i $INTERFACE -p tcp -m multiport ! --dports $REMOTE_ACCESS_PORT,$ANOTHER_EXCLUDED_PORT -j REDIRECT --to-port $MELODY_HTTP_PORT Example : sudo iptables -A PREROUTING -t nat -i ens3 -p tcp -m multiport ! --dports 1234,5678 -j REDIRECT --to-port 10800 Here the ports 1234 and 5678 have been excluded from the redirection. Note Using the sudo iptables -t nat -L PREROUTING -n -v command, you should see something like this : Chain PREROUTING (policy ACCEPT 1226K packets, 57M bytes) pkts bytes target prot opt in out source destination 25M 1243M REDIRECT tcp -- ens3 * 0.0.0.0/0 0.0.0.0/0 multiport dports !1234,5678 redir ports 10800 Important This is only used to virtually connect the HTTP server to all the ports. As Melody sits on the data link layer, the program will receive the packets before being handled by network layer programs such as iptables or ufw . Note I won't cover it here as I'm now knowledgeable enough on this, but you'll want to look at advfirewall and the portproxy command to replicate this on Windows. Berkley Packet Filter (BPF) # The next step is the customization of the filter.bpf file. This is where you filter the data that reaches Melody. By default, only inbound traffic is allowed and all 127.0.0.0/24 subnet are banned. Note You can use the -F|--filter switch to set a filter via CLI. Tip If you're using a VPS, you might need to filter out the IP addresses your hosting provider uses to check the status of your server. Source IP filtering # Use [src|dst] net <network> to filter packets according to their IP. Example : inbound and not net 127.0.0.1 You can specify a range to exclude using the CIDR notation : inbound and not net 127.0.0.0/24 Port filtering # Use [src|dst] port <port> to filter packets according to their port. Example : not port 1234 You can specify a range to exclude using the CIDR notation and the portrange keyword : not portrange 1234-5678 Your filter.bpf should look like this : inbound and not port 1234 and not net 127.0.0.0/24 and not net 192.0.2.1 Important Your file should always start with the inbound keyword. I recommend adding your filter rules below, starting with an and keyword. Advanced # Here is all you need to know about the BPF syntax and here is a great source of examples to get quickly started . Rules # Melody rules are used to apply tags on matching packets. They have multiple use cases, such as monitoring emerging threats, automated droppers, vulnerability scanners, etc. You can look into the $melody/rules/rule-available and $melody/internal/rules/test_resources folders to quickly find working examples. Basics # A rule file can contain multiple rules description and constitute a ruleset. Here is a rule example that detects CVE-2020-14882 (Oracle Weblogic RCE) scans or exploitation attempts by matching either of the two URI and the HTTP verb : CVE-2020-14882 Oracle Weblogic Server RCE : layer : http version : 1.0 meta : id : 3e1d86d8-fba6-4e15-8c74-941c3375fd3e version : 1.0 author : BonjourMalware status : stable created : 2020/11/07 modified : 2020/11/07 description : \"Checking or trying to exploit CVE-2020-14882\" references : - \"https://nvd.nist.gov/vuln/detail/CVE-2020-14882\" match : http.method : is : - \"POST\" http.uri : contains|any : - \"/console/images/%252E%252E%252Fconsole.portal\" - \"/console/css/%2e\" tags : cve : \"cve-2020-14882\" vendor : \"oracle\" product : \"weblogic\" impact : \"rce\" This rule is part of the default server.yml ruleset and tag CVE-2020-14882-related packets. If a packet match, its tags will be appended to the matches field in the packet's log. See the Rules section for details on the rules syntax. Important You must generate a new UUIDv4 for each rule you create . Output # Stdout # You can redirect the output to stdout by using the -s switch. Example { \"tcp\" : { \"window\" : 512 , \"seq\" : 1906765553 , \"ack\" : 2514263732 , \"data_offset\" : 8 , \"flags\" : \"PA\" , \"urgent\" : 0 , \"payload\" : { \"content\" : \"I made a discovery today. I found a computer.\\n\" , \"base64\" : \"SSBtYWRlIGEgZGlzY292ZXJ5IHRvZGF5LiAgSSBmb3VuZCBhIGNvbXB1dGVyLgo=\" , \"truncated\" : false } }, \"ip\" : { \"version\" : 4 , \"ihl\" : 5 , \"tos\" : 0 , \"length\" : 99 , \"id\" : 39114 , \"fragbits\" : \"DF\" , \"frag_offset\" : 0 , \"ttl\" : 64 , \"protocol\" : 6 }, \"timestamp\" : \"2020-11-16T15:50:01.277828+01:00\" , \"session\" : \"bup9368o4skolf20rt8g\" , \"type\" : \"tcp\" , \"src_ip\" : \"127.0.0.1\" , \"dst_port\" : 1234 , \"matches\" : {}, \"embedded\" : {} } Dump # A dump mode is also available with the -d|--dump switch. Similar to tcpdump , it will print raw packets to stdout instead of Melody json lines. Example PACKET : 76 bytes , wire length 76 cap length 76 @ 2020-11-16 15 : 46 : 00.927899 +0100 CET - Layer 1 ( 14 bytes ) = Ethernet { Contents = [. .14 ..] Payload = [. .62 ..] SrcMAC = 00 : 00 : 00 : 00 : 00 : 00 DstMAC = 00 : 00 : 00 : 00 : 00 : 00 EthernetType = IPv4 Length = 0 } - Layer 2 ( 20 bytes ) = IPv4 { Contents = [. .20 ..] Payload = [. .42 ..] Version = 4 IHL = 5 TOS = 0 Length = 62 Id = 39110 Flags = DF FragOffset = 0 TTL = 64 Protocol = TCP Checksum = 41969 SrcIP = 127.0.0.1 DstIP = 127.0.0.1 Options = [] Padding = []} - Layer 3 ( 32 bytes ) = TCP { Contents = [. .32 ..] Payload = [. .10 ..] SrcPort = 58766 DstPort = 1234 ( search-agent ) Seq = 1906765476 Ack = 2514263732 DataOffset = 8 FIN = false SYN = false RST = false PSH = true ACK = true URG = false ECE = false CWR = false NS = false Window = 512 Checksum = 65074 Urgent = 0 Options = [ TCPOption ( NOP :), TCPOption ( NOP :), TCPOption ( Timestamps : 1712590417 / 1712586943 0 x66140e51661400bf )] Padding = []} - Layer 4 ( 10 bytes ) = Payload 10 byte ( s ) Note All the console messages are printed to stderr in order to allow piping Melody's data into jq .","title":"Quickstart"},{"location":"quickstart/#tldr","text":"","title":"TL;DR"},{"location":"quickstart/#release","text":"Get the latest release at https://github.com/bonjourmalware/actions-lab/releases . make install # Set default outfacing interface make certs # Make self signed certs for the HTTPS fileserver make default_rules # Enable the default rules make service # Create a systemd service to restart the program automatically and launch it at startup # Note that the script expects that you've installed Melody in /opt/melody sudo systemctl stop melody # Stop the service while we're configuring it Update the filter.bpf file to filter out unwanted packets. sudo systemctl start melody # Start Melody sudo systemctl status melody # Check that Melody is running The logs should start to pile up in /opt/melody/logs/melody.ndjson . tail -f /opt/melody/logs/melody.ndjson # | jq","title":"Release"},{"location":"quickstart/#from-source","text":"git clone https://github.com/bonjourmalware/melody /opt/melody cd /opt/melody make build Then continue with the steps from the release TL;DR.","title":"From source"},{"location":"quickstart/#docker","text":"mkdir -p /opt/melody/logs cd /opt/melody/ docker pull bonjourmalware/melody:latest MELODY_CLI = \"\" # Put your CLI options here. Example : MELODY_CLI=\"-s -o 'http.server.port: 5555'\" docker run \\ --net = host \\ -e \"MELODY_CLI= $MELODY_CLI \" \\ --mount type = bind,source = \" $( pwd ) \" /filter.bpf,target = /app/filter.bpf,readonly \\ # Remove this line if you're using the default filter --mount type = bind,source = \" $( pwd ) \" /config.yml,target = /app/config.yml,readonly \\ # Remove this line if you're using the default config --mount type = bind,source = \" $( pwd ) \" /logs,target = /app/logs/ \\ # The directory must exists in your current directory before running the container melody The logs should start to pile up in /opt/melody/logs/melody.ndjson .","title":"Docker"},{"location":"quickstart/#before-we-start","text":"Hi ! You'll need the following info : The name of the interface on which you want Melody to listen to wlp3s0, ens3, enp0s25, eth0... All the IP addresses to exclude from monitoring Tip Don't forget to exclude the IP from which you're SSH'ing Clone the repo to get the default rules and configuration files : git clone https://github.com/bonjourmalware/melody Tip You can also write the configuration files later or use CLI options to use it as a standalone binary","title":"Before we start"},{"location":"quickstart/#firewall","text":"Don't forget to check your firewall to ensure you're not blocking packets from reaching the sensor.","title":"Firewall"},{"location":"quickstart/#build-from-source","text":"Warning You need the libpcap headers before building Melody. Install them with : sudo apt update sudo apt install libpcap-dev Build Melody with : make build or go build -ldflags=\"-s -w -extldflags=-static\" -o melody sudo setcap cap_net_raw,cap_setpcap=ep ./melody","title":"Build from source"},{"location":"quickstart/#grab-a-release","text":"You can grab the latest release by visiting https://github.com/bonjourmalware/melody/releases/latest .","title":"Grab a release"},{"location":"quickstart/#docker_1","text":"You can also use Docker and pull the image from Docker Hub : docker pull bonjourmalware/melody:latest Run it with : docker run \\ --net=host \\ --mount type=bind,source=\"$(pwd)\"/filter.bpf,target=/app/filter.bpf,readonly \\ --mount type=bind,source=\"$(pwd)\"/config.yml,target=/app/config.yml,readonly \\ --mount type=bind,source=\"$(pwd)\"/logs,target=/app/logs/ \\ melody","title":"Docker"},{"location":"quickstart/#configuration","text":"","title":"Configuration"},{"location":"quickstart/#melody-configuration","text":"All the available configuration options are listed with their default values in the config.yml file. You'll want to look at a few things before getting started : Set the listen.interface to the one on which you want Melody to be listening on Tip On most recent linux distribution, you can run route | grep '^default' | grep -o '[^ ]*$' to find the default WAN card. Tip On Windows, you'll want an interface name like \\Device\\NPF_{4E273621-5161-46C8-895A-48D0E52A0B83} . If you find an interface name with TCP in place of NPF , try swaping both. See Find Windows interfaces for more details. Don't forget to wrap your string with ' to prevent the parsing of the escaping \\ : interface: '\\Device\\NPF_{4E273621-5161-46C8-895A-48D0E52A0B83}' Note Note that Melody listen on lo by default. You can override the listening interface with the -i switch. The dummy HTTP/S servers are enabled by default. Disable it if you're not interested by this data, or you're putting Melody next to a web application Default rules are disabled by default. You can enable them by creating a symlink for each rule to enable in the active rule directory specified in the configuration file ( $melody/rules/rules-enabled by default) Tip To create a symlink, use the following command from the root of the projet : ln -rs ./rules/rules-available/ $rule .yml ./rules/rules-enabled/ Use a wildcard to enable all the rulesets : ln -rs ./rules/rules-available/*.yml ./rules/rules-enabled/","title":"Melody configuration"},{"location":"quickstart/#https-server","text":"In order to capture the full HTTP transactions, the client must have a server to connect to. To ease that process, a dummy HTTP/S server is available. The default configuration is to answer 200 OK on every routes, along with a Server: Apache header.","title":"HTTP/S server"},{"location":"quickstart/#iptables","text":"To capture the HTTP traffic your server receives on every ports, I recommend using iptables to redirect the data from every ports to the one Melody is listening on. Danger Be very careful while applying these modifications. You must at least exclude your remote connection port using the ! --dports switch, or you will be locked out. To achieve this, add a rule to your PREROUTING table : sudo iptables -A PREROUTING -t nat -i $INTERFACE -p tcp -m multiport ! --dports $REMOTE_ACCESS_PORT,$ANOTHER_EXCLUDED_PORT -j REDIRECT --to-port $MELODY_HTTP_PORT Example : sudo iptables -A PREROUTING -t nat -i ens3 -p tcp -m multiport ! --dports 1234,5678 -j REDIRECT --to-port 10800 Here the ports 1234 and 5678 have been excluded from the redirection. Note Using the sudo iptables -t nat -L PREROUTING -n -v command, you should see something like this : Chain PREROUTING (policy ACCEPT 1226K packets, 57M bytes) pkts bytes target prot opt in out source destination 25M 1243M REDIRECT tcp -- ens3 * 0.0.0.0/0 0.0.0.0/0 multiport dports !1234,5678 redir ports 10800 Important This is only used to virtually connect the HTTP server to all the ports. As Melody sits on the data link layer, the program will receive the packets before being handled by network layer programs such as iptables or ufw . Note I won't cover it here as I'm now knowledgeable enough on this, but you'll want to look at advfirewall and the portproxy command to replicate this on Windows.","title":"iptables"},{"location":"quickstart/#berkley-packet-filter-bpf","text":"The next step is the customization of the filter.bpf file. This is where you filter the data that reaches Melody. By default, only inbound traffic is allowed and all 127.0.0.0/24 subnet are banned. Note You can use the -F|--filter switch to set a filter via CLI. Tip If you're using a VPS, you might need to filter out the IP addresses your hosting provider uses to check the status of your server.","title":"Berkley Packet Filter (BPF)"},{"location":"quickstart/#source-ip-filtering","text":"Use [src|dst] net <network> to filter packets according to their IP. Example : inbound and not net 127.0.0.1 You can specify a range to exclude using the CIDR notation : inbound and not net 127.0.0.0/24","title":"Source IP filtering"},{"location":"quickstart/#port-filtering","text":"Use [src|dst] port <port> to filter packets according to their port. Example : not port 1234 You can specify a range to exclude using the CIDR notation and the portrange keyword : not portrange 1234-5678 Your filter.bpf should look like this : inbound and not port 1234 and not net 127.0.0.0/24 and not net 192.0.2.1 Important Your file should always start with the inbound keyword. I recommend adding your filter rules below, starting with an and keyword.","title":"Port filtering"},{"location":"quickstart/#advanced","text":"Here is all you need to know about the BPF syntax and here is a great source of examples to get quickly started .","title":"Advanced"},{"location":"quickstart/#rules","text":"Melody rules are used to apply tags on matching packets. They have multiple use cases, such as monitoring emerging threats, automated droppers, vulnerability scanners, etc. You can look into the $melody/rules/rule-available and $melody/internal/rules/test_resources folders to quickly find working examples.","title":"Rules"},{"location":"quickstart/#basics","text":"A rule file can contain multiple rules description and constitute a ruleset. Here is a rule example that detects CVE-2020-14882 (Oracle Weblogic RCE) scans or exploitation attempts by matching either of the two URI and the HTTP verb : CVE-2020-14882 Oracle Weblogic Server RCE : layer : http version : 1.0 meta : id : 3e1d86d8-fba6-4e15-8c74-941c3375fd3e version : 1.0 author : BonjourMalware status : stable created : 2020/11/07 modified : 2020/11/07 description : \"Checking or trying to exploit CVE-2020-14882\" references : - \"https://nvd.nist.gov/vuln/detail/CVE-2020-14882\" match : http.method : is : - \"POST\" http.uri : contains|any : - \"/console/images/%252E%252E%252Fconsole.portal\" - \"/console/css/%2e\" tags : cve : \"cve-2020-14882\" vendor : \"oracle\" product : \"weblogic\" impact : \"rce\" This rule is part of the default server.yml ruleset and tag CVE-2020-14882-related packets. If a packet match, its tags will be appended to the matches field in the packet's log. See the Rules section for details on the rules syntax. Important You must generate a new UUIDv4 for each rule you create .","title":"Basics"},{"location":"quickstart/#output","text":"","title":"Output"},{"location":"quickstart/#stdout","text":"You can redirect the output to stdout by using the -s switch. Example { \"tcp\" : { \"window\" : 512 , \"seq\" : 1906765553 , \"ack\" : 2514263732 , \"data_offset\" : 8 , \"flags\" : \"PA\" , \"urgent\" : 0 , \"payload\" : { \"content\" : \"I made a discovery today. I found a computer.\\n\" , \"base64\" : \"SSBtYWRlIGEgZGlzY292ZXJ5IHRvZGF5LiAgSSBmb3VuZCBhIGNvbXB1dGVyLgo=\" , \"truncated\" : false } }, \"ip\" : { \"version\" : 4 , \"ihl\" : 5 , \"tos\" : 0 , \"length\" : 99 , \"id\" : 39114 , \"fragbits\" : \"DF\" , \"frag_offset\" : 0 , \"ttl\" : 64 , \"protocol\" : 6 }, \"timestamp\" : \"2020-11-16T15:50:01.277828+01:00\" , \"session\" : \"bup9368o4skolf20rt8g\" , \"type\" : \"tcp\" , \"src_ip\" : \"127.0.0.1\" , \"dst_port\" : 1234 , \"matches\" : {}, \"embedded\" : {} }","title":"Stdout"},{"location":"quickstart/#dump","text":"A dump mode is also available with the -d|--dump switch. Similar to tcpdump , it will print raw packets to stdout instead of Melody json lines. Example PACKET : 76 bytes , wire length 76 cap length 76 @ 2020-11-16 15 : 46 : 00.927899 +0100 CET - Layer 1 ( 14 bytes ) = Ethernet { Contents = [. .14 ..] Payload = [. .62 ..] SrcMAC = 00 : 00 : 00 : 00 : 00 : 00 DstMAC = 00 : 00 : 00 : 00 : 00 : 00 EthernetType = IPv4 Length = 0 } - Layer 2 ( 20 bytes ) = IPv4 { Contents = [. .20 ..] Payload = [. .42 ..] Version = 4 IHL = 5 TOS = 0 Length = 62 Id = 39110 Flags = DF FragOffset = 0 TTL = 64 Protocol = TCP Checksum = 41969 SrcIP = 127.0.0.1 DstIP = 127.0.0.1 Options = [] Padding = []} - Layer 3 ( 32 bytes ) = TCP { Contents = [. .32 ..] Payload = [. .10 ..] SrcPort = 58766 DstPort = 1234 ( search-agent ) Seq = 1906765476 Ack = 2514263732 DataOffset = 8 FIN = false SYN = false RST = false PSH = true ACK = true URG = false ECE = false CWR = false NS = false Window = 512 Checksum = 65074 Urgent = 0 Options = [ TCPOption ( NOP :), TCPOption ( NOP :), TCPOption ( Timestamps : 1712590417 / 1712586943 0 x66140e51661400bf )] Padding = []} - Layer 4 ( 10 bytes ) = Payload 10 byte ( s ) Note All the console messages are printed to stderr in order to allow piping Melody's data into jq .","title":"Dump"},{"location":"requirements/","text":"Go version # Minimum supported Go version is 1.11, but we recommend using Go 1.13+ since that's the lowest version we're using for testing. libpcap # You'll need the libpcap C headers to build the program. Install it with : sudo apt update sudo apt install libpcap-dev Note You won't need them if you're using Docker or a pre-compiled release binary. HTTPS dummy server # You'll need TLS certificates in order to use the built-in dummy HTTPS server. Use one of these commands to generate them for you : make certs or mkdir -p var/https/certs openssl req -x509 -subj \"/C=AU/ST=Some-State/O=Internet Widgits Pty Ltd/CN=localhost\" -newkey rsa:4096 -keyout var/https/certs/key.pem -out var/https/certs/cert.pem -days 3650 -nodes Warning Using these commands will overwrite any cert.pem or key.pem file already present in $melody/var/https/certs/ Tip You can also use your own by putting the key.pem and cert.pem in $melody/var/https/certs . Keep in mind that it might be used by attackers to fingerprint or gain information on your infrastructure.","title":"Requirements"},{"location":"requirements/#go-version","text":"Minimum supported Go version is 1.11, but we recommend using Go 1.13+ since that's the lowest version we're using for testing.","title":"Go version"},{"location":"requirements/#libpcap","text":"You'll need the libpcap C headers to build the program. Install it with : sudo apt update sudo apt install libpcap-dev Note You won't need them if you're using Docker or a pre-compiled release binary.","title":"libpcap"},{"location":"requirements/#https-dummy-server","text":"You'll need TLS certificates in order to use the built-in dummy HTTPS server. Use one of these commands to generate them for you : make certs or mkdir -p var/https/certs openssl req -x509 -subj \"/C=AU/ST=Some-State/O=Internet Widgits Pty Ltd/CN=localhost\" -newkey rsa:4096 -keyout var/https/certs/key.pem -out var/https/certs/cert.pem -days 3650 -nodes Warning Using these commands will overwrite any cert.pem or key.pem file already present in $melody/var/https/certs/ Tip You can also use your own by putting the key.pem and cert.pem in $melody/var/https/certs . Keep in mind that it might be used by attackers to fingerprint or gain information on your infrastructure.","title":"HTTPS dummy server"},{"location":"rules/","text":"Melody rules are used to apply tags on matching packets. They have multiple use cases, such as monitoring emerging threats, automated droppers, vulnerability scanners... Take a look in the $melody/rule-available and $melody/internal/rules/test_resources folders to quickly find working examples. First look # A rule file can contain multiple rule descriptions. Example This example detects CVE-2020-14882 (Oracle Weblogic RCE) scans or exploitation attempts by matching either of the two URI on the HTTP level : CVE-2020-14882 Oracle Weblogic Server RCE : layer : http meta : id : 3e1d86d8-fba6-4e15-8c74-941c3375fd3e version : 1.0 author : BonjourMalware status : stable created : 2020/11/07 modified : 2020/11/07 description : \"Checking or trying to exploit CVE-2020-14882\" references : - \"https://nvd.nist.gov/vuln/detail/CVE-2020-14882\" match : http.method : is : - \"POST\" http.uri : contains|any : - \"/console/images/%252E%252E%252Fconsole.portal\" - \"/console/css/%2e\" tags : cve : \"cve-2020-14882\" vendor : \"oracle\" product : \"weblogic\" impact : \"rce\" Tip You can whitelist or blacklist ports and IP addresses with the whitelist sections blacklist (not shown here). Structure # The rules have 7 sections : layer , meta , match , whitelist , blacklist , tags and embed . layer # The rule will look for matches in the specified layer 's protocol data. Each layer expose different fields depending on the protocol they represent. They're detailed in the Layers page. The following layers are supported : Key IPv4 IPv6 http \u2705 \u2705 tcp \u2705 \u2705 udp \u2705 \u2705 icmpv4 \u2705 \u274c icmpv6 \u274c \u2705 Important A single rule only applies to the targeted layer. Use multiple rules if you want to match multiple layers. meta # The meta section contains all the rule's metadata. Every keys are mandatory, except references . Key Type Description Values Examples id string Rule's unique identifier. Each rule must have a unique UUIDv4 - id: c30370f7-aaa8-41d0-a392-b56c94869128 version string Rule syntax version 1.0 version: 1.0 author string The name of the rule's author - author: BonjourMalware status string The status gives an indication of the usability of the rule stable, experimental status: stable created yyyy/mm/dd Creation date - created: 2020/11/07 modified yyyy/mm/dd Last modification date - modified: 2020/11/07 description string A quick description of what the rule is attempting to match - description: Checking or trying to exploit CVE-2020-14882 references array The status gives an indication of the usability of the rule - references: - \"https://nvd.nist.gov/vuln/detail/CVE-2020-14882\" - \"https://github.com/jas502n/CVE-2020-14882\" - ... Important You must generate a new UUIDv4 for the id of every rule you create. Sample code for Python : import uuid print ( uuid . uuid4 ()) Go ( playground ) : package main import ( \"fmt\" \"github.com/google/uuid\" ) func main (){ fmt . Println ( uuid . New ()) } match # The match block contains a set of conditions that will be checked on every packet of the rule's layer type. Here is the structure of the match section : match : any : [ true|false ] # false by default field1 : # complex condition any : [ true|false ] # false by default operator1|modifier1|modifier2 : # matching operator with its modifiers - value1 - value2 operator2 : - value field2 : # array condition - value1 - value2 field3 : value # string or number condition Conditions # A condition corresponds to a field in a packet, specified by its name. The available conditions depends on the layer key. The keys are namespaced according to the type they belong to. Example udp.payload , tcp.flags , http.uri ... There are 3 types of conditions : number , flags or complex . Number # A number. Example tcp.window : 512 Note The number types takes advantage of YAML to support octal (0o1234), hex (0x1234) and decimal (1234) representation. Flags # flags condition are made of a list of flag combination to match. The condition is valid as soon as a match is found (OR). Example tcp.flags: - \"PA\" - \"S\" This rule will match a TCP packet with its flag bits set to \"PA\" (PSH-ACK, 0x18) or \"S\" (SYN, 0x2). Note Only two fields support flags condition : tcp.flags and tcp.fragbits . Complex # The complex condition type supports matching operators and inline modifiers . To check which fields support complex conditions , take a look at the layers documentation . Matching operators # The matching operator specifies how to handle data. A single condition can be made of a set of matching operators . Important By default, a rule needs to validate all the conditions to match. However, you can specify any: true to force a rule to test all of its conditions and return a match as soon as it find a valid one. Example udp.payload : contains : - \"after all, we're all alike.\" startswith : - \"Damn kids\" any : true In this example, the condition key is udp.payload and the matching operators are contains and startswith . This rule will match if the payload of an UDP packet startswith the string \"Damn kids\" OR contains \"after all, we're all alike.\". The rule needs both to match if we remove the any: true option. Name Description is The packet's field value is strictly equal to the condition 's value contains The packet's field value contains the condition 's value startswith The packet's field value starts with the condition 's value endswith The packet's field value ends with the condition 's value Modifiers # Modifiers are a way to quickly set options for the matching operator . They live on the same line, split by | . All modifiers can be mixed at once. Important By default, a condition needs to match all of the given values (AND). However, you can use the |any modifier to reverse it and force it to test all the values and to return on the first match. Example http.body : contains|any|nocase : - \"Enter my world\" - \"the beauty of the baud\" In this example, the modifiers are any and nocase . This rule will match if the URI field of an HTTP packet contains any item in the list. Name Description Example any The rule match if any of the values in the list matches - nocase The match is case insensitive abcd == aBcD == ABCD regex The value is a regular expression '(?:[0-9]{1,3}.){3}[0-9]{1,3}' == 192.0.2.1 Danger Although the regex is compiled only once, it can cause severe overhead while matching packets. Use it with caution. Hybrid pattern # complex condition 's support hex values by wrapping them between two | . You can mix hex and ascii in a single string as well. Example http.body : contains : - \"|45 6e 74 65 72206d79| world\" Note '0x' hex notation ( |0xbe 0xef| ) is invalid. You can mix spaced and not spaced hex bytes though. Whitelist and blacklist # These two fields can be used to filter the packets on which the rule is applied. IP source addresses and ports are supported. IP address # Example whitelist : ips : - 127.0.0.1 This example only tries to match the packets coming from 127.0.0.1. blacklist : ips : - 127.0.0.1 Use the blacklist keyword to reverse the logic and apply the rule to all packets but the one coming from 127.0.0.1. Example whitelist : ips : - 127.0.0.0/24 CIDR notation supported. Ports # Example whitelist : ports : - 80 This example only tries to match the packets going to port 80 . blacklist : ports : - 80 Use the blacklist keyword to reverse the logic and apply the rule to all packets but the one going to port 80. Example whitelist : ports : - 8000 - 9000 Port ranges are supported. You can choose to put spaces or not. tags # Each of the key/value pair in the tags object will be appended to the matches field of each of the matching packets. embed # This is a block where the user can will embed any data in the embedded key of the matching packet. It can be used as an alternative to tags to add contextual information. Example embed : my_crime : \"curiosity\" ...","title":"Rules"},{"location":"rules/#first-look","text":"A rule file can contain multiple rule descriptions. Example This example detects CVE-2020-14882 (Oracle Weblogic RCE) scans or exploitation attempts by matching either of the two URI on the HTTP level : CVE-2020-14882 Oracle Weblogic Server RCE : layer : http meta : id : 3e1d86d8-fba6-4e15-8c74-941c3375fd3e version : 1.0 author : BonjourMalware status : stable created : 2020/11/07 modified : 2020/11/07 description : \"Checking or trying to exploit CVE-2020-14882\" references : - \"https://nvd.nist.gov/vuln/detail/CVE-2020-14882\" match : http.method : is : - \"POST\" http.uri : contains|any : - \"/console/images/%252E%252E%252Fconsole.portal\" - \"/console/css/%2e\" tags : cve : \"cve-2020-14882\" vendor : \"oracle\" product : \"weblogic\" impact : \"rce\" Tip You can whitelist or blacklist ports and IP addresses with the whitelist sections blacklist (not shown here).","title":"First look"},{"location":"rules/#structure","text":"The rules have 7 sections : layer , meta , match , whitelist , blacklist , tags and embed .","title":"Structure"},{"location":"rules/#layer","text":"The rule will look for matches in the specified layer 's protocol data. Each layer expose different fields depending on the protocol they represent. They're detailed in the Layers page. The following layers are supported : Key IPv4 IPv6 http \u2705 \u2705 tcp \u2705 \u2705 udp \u2705 \u2705 icmpv4 \u2705 \u274c icmpv6 \u274c \u2705 Important A single rule only applies to the targeted layer. Use multiple rules if you want to match multiple layers.","title":"layer"},{"location":"rules/#meta","text":"The meta section contains all the rule's metadata. Every keys are mandatory, except references . Key Type Description Values Examples id string Rule's unique identifier. Each rule must have a unique UUIDv4 - id: c30370f7-aaa8-41d0-a392-b56c94869128 version string Rule syntax version 1.0 version: 1.0 author string The name of the rule's author - author: BonjourMalware status string The status gives an indication of the usability of the rule stable, experimental status: stable created yyyy/mm/dd Creation date - created: 2020/11/07 modified yyyy/mm/dd Last modification date - modified: 2020/11/07 description string A quick description of what the rule is attempting to match - description: Checking or trying to exploit CVE-2020-14882 references array The status gives an indication of the usability of the rule - references: - \"https://nvd.nist.gov/vuln/detail/CVE-2020-14882\" - \"https://github.com/jas502n/CVE-2020-14882\" - ... Important You must generate a new UUIDv4 for the id of every rule you create. Sample code for Python : import uuid print ( uuid . uuid4 ()) Go ( playground ) : package main import ( \"fmt\" \"github.com/google/uuid\" ) func main (){ fmt . Println ( uuid . New ()) }","title":"meta"},{"location":"rules/#match","text":"The match block contains a set of conditions that will be checked on every packet of the rule's layer type. Here is the structure of the match section : match : any : [ true|false ] # false by default field1 : # complex condition any : [ true|false ] # false by default operator1|modifier1|modifier2 : # matching operator with its modifiers - value1 - value2 operator2 : - value field2 : # array condition - value1 - value2 field3 : value # string or number condition","title":"match"},{"location":"rules/#conditions","text":"A condition corresponds to a field in a packet, specified by its name. The available conditions depends on the layer key. The keys are namespaced according to the type they belong to. Example udp.payload , tcp.flags , http.uri ... There are 3 types of conditions : number , flags or complex .","title":"Conditions"},{"location":"rules/#number","text":"A number. Example tcp.window : 512 Note The number types takes advantage of YAML to support octal (0o1234), hex (0x1234) and decimal (1234) representation.","title":"Number"},{"location":"rules/#flags","text":"flags condition are made of a list of flag combination to match. The condition is valid as soon as a match is found (OR). Example tcp.flags: - \"PA\" - \"S\" This rule will match a TCP packet with its flag bits set to \"PA\" (PSH-ACK, 0x18) or \"S\" (SYN, 0x2). Note Only two fields support flags condition : tcp.flags and tcp.fragbits .","title":"Flags"},{"location":"rules/#complex","text":"The complex condition type supports matching operators and inline modifiers . To check which fields support complex conditions , take a look at the layers documentation .","title":"Complex"},{"location":"rules/#matching-operators","text":"The matching operator specifies how to handle data. A single condition can be made of a set of matching operators . Important By default, a rule needs to validate all the conditions to match. However, you can specify any: true to force a rule to test all of its conditions and return a match as soon as it find a valid one. Example udp.payload : contains : - \"after all, we're all alike.\" startswith : - \"Damn kids\" any : true In this example, the condition key is udp.payload and the matching operators are contains and startswith . This rule will match if the payload of an UDP packet startswith the string \"Damn kids\" OR contains \"after all, we're all alike.\". The rule needs both to match if we remove the any: true option. Name Description is The packet's field value is strictly equal to the condition 's value contains The packet's field value contains the condition 's value startswith The packet's field value starts with the condition 's value endswith The packet's field value ends with the condition 's value","title":"Matching operators"},{"location":"rules/#modifiers","text":"Modifiers are a way to quickly set options for the matching operator . They live on the same line, split by | . All modifiers can be mixed at once. Important By default, a condition needs to match all of the given values (AND). However, you can use the |any modifier to reverse it and force it to test all the values and to return on the first match. Example http.body : contains|any|nocase : - \"Enter my world\" - \"the beauty of the baud\" In this example, the modifiers are any and nocase . This rule will match if the URI field of an HTTP packet contains any item in the list. Name Description Example any The rule match if any of the values in the list matches - nocase The match is case insensitive abcd == aBcD == ABCD regex The value is a regular expression '(?:[0-9]{1,3}.){3}[0-9]{1,3}' == 192.0.2.1 Danger Although the regex is compiled only once, it can cause severe overhead while matching packets. Use it with caution.","title":"Modifiers"},{"location":"rules/#hybrid-pattern","text":"complex condition 's support hex values by wrapping them between two | . You can mix hex and ascii in a single string as well. Example http.body : contains : - \"|45 6e 74 65 72206d79| world\" Note '0x' hex notation ( |0xbe 0xef| ) is invalid. You can mix spaced and not spaced hex bytes though.","title":"Hybrid pattern"},{"location":"rules/#whitelist-and-blacklist","text":"These two fields can be used to filter the packets on which the rule is applied. IP source addresses and ports are supported.","title":"Whitelist and blacklist"},{"location":"rules/#ip-address","text":"Example whitelist : ips : - 127.0.0.1 This example only tries to match the packets coming from 127.0.0.1. blacklist : ips : - 127.0.0.1 Use the blacklist keyword to reverse the logic and apply the rule to all packets but the one coming from 127.0.0.1. Example whitelist : ips : - 127.0.0.0/24 CIDR notation supported.","title":"IP address"},{"location":"rules/#ports","text":"Example whitelist : ports : - 80 This example only tries to match the packets going to port 80 . blacklist : ports : - 80 Use the blacklist keyword to reverse the logic and apply the rule to all packets but the one going to port 80. Example whitelist : ports : - 8000 - 9000 Port ranges are supported. You can choose to put spaces or not.","title":"Ports"},{"location":"rules/#tags","text":"Each of the key/value pair in the tags object will be appended to the matches field of each of the matching packets.","title":"tags"},{"location":"rules/#embed","text":"This is a block where the user can will embed any data in the embedded key of the matching packet. It can be used as an alternative to tags to add contextual information. Example embed : my_crime : \"curiosity\" ...","title":"embed"},{"location":"use_cases/","text":"","title":"Use cases"}]}